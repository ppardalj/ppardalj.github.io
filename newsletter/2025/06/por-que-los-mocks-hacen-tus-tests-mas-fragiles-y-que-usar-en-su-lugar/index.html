<!doctype html><html lang=es><head><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-PJM6WP")</script><meta charset=utf-8><title>Por que los mocks hacen tus tests mas fragiles (y que usar en su lugar) | Pedro Pardal</title>
<meta name=description content="Hay una alternativa mas robusta y expresiva: los fakes."><meta name=author content="Pedro Pardal"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:url" content="https://www.ppardalj.com/newsletter/2025/06/por-que-los-mocks-hacen-tus-tests-mas-fragiles-y-que-usar-en-su-lugar/"><meta property="og:site_name" content="Pedro Pardal"><meta property="og:title" content="Por que los mocks hacen tus tests mas fragiles (y que usar en su lugar)"><meta property="og:description" content="Hay una alternativa mas robusta y expresiva: los fakes."><meta property="og:locale" content="es"><meta property="og:type" content="article"><meta property="article:section" content="newsletter"><meta property="article:published_time" content="2025-06-11T00:00:00+00:00"><meta property="article:modified_time" content="2025-06-11T00:00:00+00:00"><meta property="article:tag" content="Newsletter"><meta property="og:image" content="https://www.ppardalj.com/images/blog/posts/programador.jpg"><meta itemprop=name content="Por que los mocks hacen tus tests mas fragiles (y que usar en su lugar)"><meta itemprop=description content="Hay una alternativa mas robusta y expresiva: los fakes."><meta itemprop=datePublished content="2025-06-11T00:00:00+00:00"><meta itemprop=dateModified content="2025-06-11T00:00:00+00:00"><meta itemprop=wordCount content="2491"><meta itemprop=image content="https://www.ppardalj.com/images/blog/posts/programador.jpg"><meta itemprop=keywords content="Newsletter"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.ppardalj.com/images/blog/posts/programador.jpg"><meta name=twitter:title content="Por que los mocks hacen tus tests mas fragiles (y que usar en su lugar)"><meta name=twitter:description content="Hay una alternativa mas robusta y expresiva: los fakes."><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css integrity=sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm crossorigin=anonymous><link rel=stylesheet href=https://www.ppardalj.com/scss/main.css><link rel=stylesheet href=https://www.ppardalj.com/scss/hero.css><script type=text/javascript id=hs-script-loader async defer src=//js.hs-scripts.com/8231847.js></script><link rel=stylesheet type=text/css href=https://cdn.jsdelivr.net/npm/cookieconsent@3/build/cookieconsent.min.css><link rel=stylesheet href=https://www.ppardalj.com/scss/blog.css><link rel=stylesheet href=https://www.ppardalj.com/scss/hero.css></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PJM6WP" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><nav class="navbar navbar-dark dark navbar-expand-lg navbar-shrink"><div class=container><a href=/ class=navbar-brand><p>Pedro Pardal</p></a><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarTogglerDemo01 aria-controls=navbarTogglerDemo01 aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarTogglerDemo01><ul class="navbar-nav ml-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Servicios</a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/team-coaching/>Team Coaching</a>
<a class=dropdown-item href=https://www.exeal.com/>Cursos</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownResources role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Recursos</a><div class=dropdown-menu aria-labelledby=navbarDropdownResources><a class=dropdown-item href=/newsletter/>Newsletter</a>
<a class=dropdown-item href=/blog/>Blog</a></div></li><li class=nav-item><a class="nav-link nav-button" href=/contacto/>Contacto</a></li></ul></div></div></nav><header class="hero hero-bg-img" style=background-image:url(/images/blog/posts/programador.jpg)><div class="hero-bg-img-mask bg-mask"><div class="container h-100"><div class="row h-100 align-items-center"><div class="col-12 text-center"><h1><span class=underline>Por que los mocks hacen tus tests mas fragiles (y que usar en su lugar)</span></h1></div></div></div></div></header><section id=sect-body><div class=container><article><p>Has escrito tus tests. Todo verde. Refactorizas una clase… y <em>boom</em>, 17 tests rotos.</p><p>Pero no porque el sistema haya dejado de funcionar. Sino porque el <strong>mock esperaba un orden de llamadas exacto</strong>, y ahora haces <code>Validate()</code> antes que <code>DoThing()</code>.</p><p>O porque cambiaste el nombre de un método privado. Que ni siquiera forma parte del contrato público. Pero el test lo usaba como si fuera sagrado.</p><p>Lo arreglas. Vuelve el verde. Respiras.</p><p>Y entonces lo ves: <strong>el test no valida ningún resultado real</strong>. Solo que se llamaron ciertas funciones con ciertos parámetros.</p><p>En producción, el sistema se comporta distinto. Y no te enteras hasta que ya es tarde.</p><p>Porque ese mock —que parecía tan útil— <strong>nunca estuvo obligado a comportarse como el sistema real</strong>.</p><p>Y ese es el problema de fondo: <strong>estás probando contra algo que no tiene por qué cumplir el contrato</strong>.</p><p>Para entender por qué ocurre —y cómo dejar de pisarte la manguera—, hay que volver a un concepto básico del testing: los <strong>dobles de test</strong>.</p><hr><h2 id=qué-son-los-dobles-de-test-y-por-qué-importan>Qué son los dobles de test (y por qué importan)</h2><p>Cuando escribes un test y no quieres que participe una clase real (una base de datos, una API externa, un gateway de pagos…), usas un <em>doble de test</em>.</p><p>Un doble de test es, simplemente, <strong>una pieza que sustituye a otra en un test</strong>.</p><p>Dentro de esa categoría hay varios tipos (stubs, spies, dummies…). Esta clasificación viene del trabajo de Martin Fowler en su artículo <a href=https://martinfowler.com/articles/mocksArentStubs.html><em>Mocks Aren’t Stubs</em></a>, donde explica las diferencias entre dobles basados en comportamiento (mocks) y los que simplemente simulan datos (fakes, stubs, etc.).</p><p>Sin embargo, para lo que nos interesa aquí, podemos simplificar el mapa en dos grandes grupos: <strong>mocks</strong> y <strong>fakes</strong>.</p><h3 id=un-caso-a-testear-registro-de-usuario>Un caso a testear: registro de usuario</h3><p>Supón que tienes una clase <code>UserRegistrationService</code> que registra un usuario si no existe ya en el sistema:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserRegistrationService</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IUserRepository _repository;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> UserRegistrationService(IUserRepository repository)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _repository = repository;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> Register(<span style=color:#66d9ef>string</span> email)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> existing = _repository.FindByEmail(email);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (existing != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        _repository.Save(<span style=color:#66d9ef>new</span> User(email));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>La interfaz <code>IUserRepository</code> es simple:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IUserRepository</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Save(User user);
</span></span><span style=display:flex><span>    User? FindByEmail(<span style=color:#66d9ef>string</span> email);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Vamos a ver cómo se puede testear esto con mocks&mldr; y con fakes.</p><h3 id=los-mocks>Los mocks</h3><p>Un <em>mock</em> es un objeto que <strong>configuras desde el test</strong> para que devuelva ciertos valores y registre las llamadas que se le hacen.</p><p>Lo usas así:</p><ul><li>Le dices qué debe devolver si se llama al método X con el parámetro Y.</li><li>Luego, después de ejecutar el código, verificas que ese método se haya llamado como tú esperabas.</li></ul><p>Es como un actor que <strong>sigue el guion que tú le marcas,</strong> y luego te pasa el informe de todo lo que ha hecho.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> repoMock = <span style=color:#66d9ef>new</span> Mock&lt;IUserRepository&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>repoMock.Setup(r =&gt; r.FindByEmail(<span style=color:#e6db74>&#34;pedro@exeal.com&#34;</span>)).Returns((User?)<span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> service = <span style=color:#66d9ef>new</span> UserRegistrationService(repoMock.Object);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> result = service.Register(<span style=color:#e6db74>&#34;pedro@exeal.com&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Assert.True(result);
</span></span><span style=display:flex><span>repoMock.Verify(r =&gt; r.Save(It.Is&lt;User&gt;(u =&gt; u.Email == <span style=color:#e6db74>&#34;pedro@exeal.com&#34;</span>)));
</span></span></code></pre></div><p>Este test no valida ningún resultado observable. Solo que se llamaron ciertos métodos con ciertos parámetros.</p><p>El mock es como un actor que improvisa (pero mal) con tu guion: puede decir cualquier cosa… incluso si contradice la historia.</p><h3 id=los-fakes>Los fakes</h3><p>Un <em>fake</em>, en cambio, es <strong>una implementación funcional del contrato</strong>, que se comporta de forma coherente, aunque simplificada.</p><p>Por ejemplo: un <code>FakeUserRepository</code> que guarda usuarios en una lista en memoria. No hay <code>.Setup()</code>, no hay <code>.Verify()</code>. Solo comportamiento.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FakeUserRepository</span> : IUserRepository
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> List&lt;User&gt; _users = <span style=color:#66d9ef>new</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Save(User user) =&gt; _users.Add(user);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> User? FindByEmail(<span style=color:#66d9ef>string</span> email) =&gt;
</span></span><span style=display:flex><span>        _users.FirstOrDefault(u =&gt; u.Email == email);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> repo = <span style=color:#66d9ef>new</span> FakeUserRepository();
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> service = <span style=color:#66d9ef>new</span> UserRegistrationService(repo);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> result = service.Register(<span style=color:#e6db74>&#34;pedro@exeal.com&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Assert.True(result);
</span></span><span style=display:flex><span>Assert.NotNull(repo.FindByEmail(<span style=color:#e6db74>&#34;pedro@exeal.com&#34;</span>));
</span></span></code></pre></div><p>Aquí el test valida un efecto real: que el usuario se ha guardado correctamente.</p><p>No le importa cómo se logró internamente. Le importa lo que el sistema hizo.</p><p>Entender esta diferencia lo cambia todo. Porque, aunque los dos sirven para sustituir dependencias en los tests, <strong>solo uno de ellos se comporta como un sistema real</strong>. Y no es el mock.</p><hr><h2 id=por-qué-los-mocks-generan-dolor><strong>Por qué los mocks generan dolor</strong></h2><p>A primera vista, usar mocks parece cómodo: sustituyen dependencias externas, te permiten configurar comportamientos… y puedes verificar que se llama a lo que toca.</p><p>Pero esa comodidad tiene trampa.</p><p>En cuanto haces un refactor mínimamente serio, los tests empiezan a romperse. No porque el sistema falle, sino porque <strong>el test estaba acoplado a la implementación interna</strong>.</p><h3 id=1-fragilidad-ante-refactors>1. Fragilidad ante refactors</h3><p>¿Extraes un método privado? ¿Cambias el orden de ejecución? ¿Renombras un parámetro?</p><p>Aunque el comportamiento externo no cambie, los tests con mocks pueden fallar.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>repoMock.Verify(r =&gt; r.Save(...));
</span></span></code></pre></div><p>Este tipo de verificación exige que el sistema funcione de una forma exacta. Si el <em>cómo</em> cambia, el test falla… aunque el <em>qué</em> siga estando bien.</p><h3 id=2-testean-configuraciones-no-comportamientos>2. Testean configuraciones, no comportamientos</h3><p>Un mock es tan listo como tú lo hagas. Tú decides qué devuelve. Pero lo haces de forma aislada, sin que dependa del flujo de ejecución.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>repoMock.Setup(r =&gt; r.FindByEmail(<span style=color:#e6db74>&#34;pedro@exeal.com&#34;</span>)).Returns((User?)<span style=color:#66d9ef>null</span>);
</span></span></code></pre></div><p>Aquí el test declara que el usuario no existe, pero sin ninguna causa previa. <strong>No estás describiendo el estado real del sistema, sino inyectando una simulación arbitraria.</strong></p><p>Eso crea una falsa sensación de seguridad. El test pasa, pero no valida el comportamiento del sistema real.</p><p>Has sido “mockeado” :P</p><h3 id=3-ruido-y-verbosidad>3. Ruido y verbosidad</h3><p>Mocks requieren configurar <code>.Setup()</code>, <code>.Returns()</code>, <code>.Verify()</code>&mldr;</p><p>Y si hay varios en un mismo test, el código se llena de detalles irrelevantes.</p><p>Cuesta leer qué se está probando. Cuesta ver la intención. El test ya no cuenta una historia: es una receta mecánica de configuraciones.</p><h3 id=4-alta-duplicación-y-mantenimiento-costoso>4. Alta duplicación y mantenimiento costoso</h3><p>Cada test repite las mismas configuraciones. Cambias una firma o una lógica interna… y tienes que tocar decenas de líneas en decenas de tests.</p><p>Ese esfuerzo se multiplica con el tiempo y acaba erosionando la confianza en el valor de los tests.</p><h3 id=5-rompen-el-contrato-semántico-de-las-dependencias>5. Rompen el contrato semántico de las dependencias</h3><p>El mayor riesgo: puedes configurar un mock para devolver respuestas que <strong>no tienen sentido en ningún flujo real</strong>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>repoMock.Setup(r =&gt; r.FindByEmail(<span style=color:#e6db74>&#34;pedro@exeal.com&#34;</span>))
</span></span><span style=display:flex><span>        .Returns(<span style=color:#66d9ef>new</span> User(<span style=color:#e6db74>&#34;pedro@exeal.com&#34;</span>));
</span></span></code></pre></div><p>Aquí el test simula que el usuario existe… sin que nunca se haya guardado.</p><p>Ese desacoplamiento entre <em>lo que el sistema haría</em> y <em>lo que el mock devuelve</em> <strong>rompe el contrato implícito entre las partes</strong>.</p><p>Ya no estás probando el sistema. Estás probando una historia inventada.</p><p>Gerard Meszaros lo resume bien en <a href=https://www.amazon.es/xUnit-Test-Patterns-Refactoring-Signature/dp/0131495054><em>xUnit Test Patterns</em></a>: cuando un doble no se comporta como su colaborador real, el test pierde valor como verificación del sistema. Especialmente si la verificación se basa en interacciones, no en resultados.</p><p>Hasta aquí, hemos visto cómo los mocks pueden darte una falsa sensación de seguridad.</p><p>Pero… ¿cuál es la alternativa?</p><p>Visto lo que no funciona, vamos a ver qué sí lo hace.</p><h2 id=qué-ventajas-tienen-los-fakes><strong>Qué ventajas tienen los fakes</strong></h2><p>Frente a los problemas de los mocks, los fakes ofrecen una alternativa más robusta y sostenible. Son simples de escribir, fáciles de entender y se comportan como versiones mínimas del sistema real.</p><p>Vamos con las ventajas concretas:</p><h3 id=1-se-escriben-una-vez-y-se-reutilizan>1. Se escriben una vez y se reutilizan</h3><p>Un fake es código real. Lo implementas una vez —normalmente en memoria— y puedes usarlo en todos los tests que lo necesiten.</p><p>Mientras que con mocks estás escribiendo <code>.Setup</code> y <code>.Returns</code> en cada test, con fakes lo único que cambias es el escenario.</p><h3 id=2-modelan-el-comportamiento-real-del-sistema>2. Modelan el comportamiento real del sistema</h3><p>El <code>FakeUserRepository</code> que vimos antes guarda usuarios en una lista y permite buscarlos.</p><p>No hay nada que configurar. Solo haces <code>Save()</code> y luego <code>FindByEmail()</code>.</p><p>Eso ya es suficiente para detectar errores de lógica, flujos incoherentes o datos mal gestionados. Porque el fake <strong>tiene reglas internas reales</strong>, no una simulación arbitraria.</p><h3 id=3-permiten-tests-orientados-a-resultados-no-a-llamadas>3. Permiten tests orientados a resultados, no a llamadas</h3><p>Con mocks, los tests suelen verificar <em>si se llamó a algo</em>.</p><p>Con fakes, verificas <em>qué pasó realmente</em>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// Con fake</span>
</span></span><span style=display:flex><span>service.Register(<span style=color:#e6db74>&#34;pedro@exeal.com&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> user = repo.FindByEmail(<span style=color:#e6db74>&#34;pedro@exeal.com&#34;</span>);
</span></span><span style=display:flex><span>Assert.NotNull(user);
</span></span></code></pre></div><p>Este test no necesita saber cómo se implementa <code>Register()</code>. Solo le importa el resultado observable.</p><h3 id=4-pueden-actuar-como-contratos-ejecutables>4. Pueden actuar como contratos ejecutables</h3><p>Si testéas bien tus fakes (con casos límite, reglas del dominio, validaciones&mldr;), acaban convirtiéndose en <strong>especificaciones vivas</strong> del comportamiento esperado de la dependencia.</p><p>Son una forma de protegerte contra cambios arbitrarios, igual que lo harías con tests de producción.</p><h3 id=5-no-necesitas-librerías-externas>5. No necesitas librerías externas</h3><p>Nada de frameworks. Nada de DSLs raros. Solo código.</p><p>Y eso hace que tus tests sean más portables, más claros y menos frágiles.</p><hr><h2 id=cuándo-tiene-sentido-usar-fakes-y-cuándo-no><strong>Cuándo tiene sentido usar fakes (y cuándo no)</strong></h2><p>No todo se puede —ni se debe— fakear. Hay casos donde un mock es la opción más razonable, <strong>no porque sea ideal, sino porque es suficiente</strong>.</p><h3 id=casos-ideales-para-usar-fakes>Casos ideales para usar fakes</h3><ul><li><strong>Repositorios</strong>: tienen comportamiento, almacenan estado y devuelven datos. Perfectos para fakear.</li><li><strong>Adaptadores a servicios externos</strong> (APIs de terceros, gateways de pagos, etc.): puedes simular su lógica en memoria sin depender del mundo real.</li><li><strong>Colaboradores con reglas de negocio</strong>: si tiene condiciones, invariantes o efectos visibles, un fake bien diseñado ayuda a testear mejor.</li></ul><h3 id=casos-límite-donde-un-mock-es-suficiente-y-sensato>Casos límite donde un mock es suficiente (y sensato)</h3><ul><li><strong>Loggers, métricas, sistemas de auditoría</strong>: no devuelven nada, solo notifican. Mockearlos para verificar que se llamó a <code>LogError()</code> puede ser suficiente.</li><li><strong>Notificaciones, emails, webhooks</strong>: si lo único que necesitas es comprobar que se disparó una acción, no tiene sentido montar un fake complejo.</li><li><strong>Sistemas tan simples que fakearlos sería más trabajo que valor</strong>: si la colaboración no aporta lógica, construir un fake es sobreingeniería.</li></ul><h3 id=regla-de-oro>Regla de oro:</h3><blockquote><p><em>Mocks para interacciones sin efecto.</em></p><p><em><strong>Fakes para colaboraciones con comportamiento.</strong></em></p></blockquote><p>Dicho de otro modo: si solo necesitas saber <em>si se llamó a algo</em>, el mock vale.</p><p>Pero si quieres saber <em>qué hace ese algo</em>, entonces el fake es tu aliado.</p><h2 id=buenas-prácticas-si-decides-usar-fakes><strong>Buenas prácticas si decides usar fakes</strong></h2><p>Pasarte a los fakes no es solo cambiar cómo sustituyes una dependencia.</p><p>Es adoptar un enfoque de testing más realista, más expresivo y más conectado con el dominio.</p><p>Pero para que eso funcione, hay que hacerlos bien. Aquí van algunas pautas clave:</p><h3 id=1-testéalos-como-si-fueran-código-de-producción>1. Testéalos como si fueran código de producción</h3><p>Un fake no es un segundo plato. Si encapsula reglas del dominio, <strong>debe estar bien cubierto por tests</strong>.</p><ul><li>¿Qué pasa si llamas a <code>FindByEmail()</code> sin haber guardado nada?</li><li>¿Permite duplicados? ¿Lanza excepción? ¿Devuelve siempre el último?</li></ul><p>Asegúrate de capturar casos límite, validar invariantes y cumplir pre/postcondiciones.</p><p>Cuanto más robusto es el fake, más confianza te da toda la suite.</p><h3 id=2-usa-la-gestión-de-errores-funcional-para-capturar-mejor-el-comportamiento>2. Usa la gestión de errores funcional para capturar mejor el comportamiento</h3><p>Una de las ventajas de usar fakes es que <strong>te obliga a pensar en serio cómo debería comportarse una colaboración</strong>.</p><p>Y eso incluye cómo representar errores o condiciones excepcionales.</p><p>Por ejemplo:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>User? FindByEmail(<span style=color:#66d9ef>string</span> email);
</span></span></code></pre></div><p>Esta firma parece suficiente… hasta que tienes que implementar el fake.</p><p>¿Devuelves <code>null</code> si no lo encuentra? ¿Y si el email está mal formado? ¿Y si el sistema no está disponible?</p><p>Ahí es donde te das cuenta de que la firma <strong>no te obliga a modelar explícitamente los posibles resultados</strong>.</p><p>Y eso puede llevar a ambigüedades, bugs y tests frágiles.</p><p>Si usas un tipo como <code>Result&lt;User, NotFound></code> o <code>Either&lt;Error, User></code>, esa ambigüedad desaparece:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Result&lt;User, NotFound&gt; FindByEmail(<span style=color:#66d9ef>string</span> email);
</span></span></code></pre></div><p>Ahora el contrato es claro: o devuelves un usuario, o un error bien tipado.</p><p>Y tanto el fake como el código de producción se benefician de esa precisión.</p><p>¿Podrías hacer esto con mocks? Claro.</p><p>Pero los mocks no te obligan a enfrentarte al diseño.</p><p>Los fakes, sí. Y eso es parte de su valor.</p><h3 id=3-mantenlos-cerca-del-dominio>3. Mantenlos cerca del dominio</h3><p>Un buen fake <strong>cuenta una historia coherente</strong>.</p><p>Si estás modelando un <code>FakePaymentGateway</code>, ¿qué ocurre si el usuario no tiene saldo?</p><p>¿Permite repetir pagos con el mismo ID? ¿Puedes consultar el estado de un cobro?</p><p>Cuanto más alineado esté con las reglas reales, más útil será para detectar errores <em>antes</em> de llegar a producción.</p><h3 id=en-resumen>En resumen:</h3><blockquote><p><em>Si tratas a tus fakes como código de juguete, obtendrás tests de juguete.
Si los tratas como parte del sistema, se convierten en contratos ejecutables.</em></p></blockquote><hr><h3 id=cómo-migrar-de-mocks-a-fakes-paso-a-paso><strong>Cómo migrar de mocks a fakes (paso a paso)</strong></h3><p>No hace falta reescribir toda tu suite de tests de golpe.</p><p>Puedes empezar poco a poco, y <strong>cada paso mejora tu diseño y tus tests</strong>.</p><p>Aquí va una guía para migrar de mocks a fakes de forma progresiva y sostenible:</p><h3 id=paso-1-identifica-los-colaboradores-que-más-mockeas>Paso 1. Identifica los colaboradores que más mockeas</h3><p>Abre tus tests y mira qué dependencias estás simulando constantemente.</p><p>Suelen ser cosas como:</p><ul><li>Repositorios</li><li>Gateways a servicios externos</li><li>Adaptadores de infraestructura</li></ul><p><strong>Si ves <code>.Setup(...)</code> y <code>.Returns(...)</code> repetido en todos lados, tienes un candidato.</strong></p><h3 id=paso-2-escribe-un-primer-fakex-sencillo>Paso 2. Escribe un primer <code>FakeX</code> sencillo</h3><p>Crea una implementación in-memory que haga lo mínimo para comportarse como la clase real.</p><p>Por ejemplo, si tienes un <code>IUserRepository</code>, escribe un <code>FakeUserRepository</code> que guarde usuarios en una lista y te deje buscarlos.</p><p>No hace falta cubrir todos los casos al principio. <strong>Empieza por los tests más simples.</strong></p><h3 id=paso-3-testea-ese-fake-como-si-fuera-código-de-producción>Paso 3. Testea ese fake como si fuera código de producción</h3><p>El fake <strong>no es código de test</strong>, es <strong>infraestructura de confianza</strong>.</p><p>Escribe tests para validar:</p><ul><li>Qué pasa si buscas un usuario que no existe</li><li>Qué ocurre si guardas dos con el mismo email</li><li>Qué invariantes debe cumplir ese colaborador</li></ul><p><strong>Cuanto más lo testees, más robusta será tu suite.</strong></p><h3 id=paso-4-sustituye-mocks-por-el-fake>Paso 4. Sustituye mocks por el fake</h3><p>Ve test a test. Sustituye el mock por tu fake, elimina <code>.Setup()</code> y <code>.Verify()</code>, y valida el resultado del sistema directamente.</p><p>Lo más probable es que los tests sean más cortos, más claros y más expresivos.</p><h3 id=paso-5-usa-los-fallos-como-oportunidad>Paso 5. Usa los fallos como oportunidad</h3><p>Puede que algún test empiece a fallar.</p><p>Bien.</p><p>Eso te está diciendo que había una <strong>asimetría entre lo que el mock prometía y lo que el sistema real hace</strong>.</p><p>Aprovecha para replantear:</p><ul><li>¿Está bien diseñada esta interfaz?</li><li>¿El sistema se comporta como esperas?</li><li>¿Dónde debería estar esta lógica?</li></ul><p>Migrar a fakes es también una forma de <strong>refinar tus colaboraciones y tus contratos</strong>.</p><hr><h2 id=conclusión-menos-mocks-mejores-tests>Conclusión: menos mocks, mejores tests</h2><p>Muchos tests pasan.</p><p>Pocos tests protegen de verdad.</p><p>Cuando abusamos de los mocks, no estamos validando comportamiento real. Solo estamos comprobando que el sistema hace las llamadas que esperábamos… aunque el resultado final sea incorrecto.</p><p>Los fakes, bien usados, nos devuelven a lo importante: el comportamiento observable, el diseño orientado a propósito, la confianza real en que nuestro sistema hace lo que dice hacer.</p><p>Pero eso es solo una pieza del puzzle.</p><h3 id=y-si-el-problema-no-fuera-solo-el-tipo-de-doble-que-usas>¿Y si el problema no fuera solo el tipo de doble que usas?</h3><ul><li>¿Cómo sabes que tus tests cubren lo que importa?</li><li>¿Qué tipo de test es el adecuado en cada capa?</li><li>¿Cómo construir una red de tests que aguante el paso del tiempo?</li></ul><p>Aquí hemos hablado de mocks y fakes.</p><p>En la formación <strong>“A prueba de fallos”</strong>, vamos un paso más allá: te enseño a diseñar toda tu estrategia de testing para que sea una red de seguridad real — sin agujeros, sin ruido y sin sobrecoste.</p><p>👉 <a href=http://www.exeal.com/cursos/a-prueba-de-fallos><strong>Descubre cómo blindar tu sistema con una estrategia de tests que aguanta lo que le eches.</strong></a></p><p>Si alguna vez has tenido bugs en producción con todos los tests en verde, esta formación te ayudará a que no vuelva a pasar.</p><p>Un abrazo,</p><p>Pedro</p></article></div><div class=container><div class="row h-100 align-items-center"><div class="col-12 text-center"><ul class="tags tags-dark"><li><a href=https://www.ppardalj.com/tags/newsletter/>#newsletter</a></li></ul><div class=addthis_inline_share_toolbox></div></div></div></div></section><footer class=black><div class=container><div class="row align-items-center"><div class="col-lg-6 text-lg-left"><a href=/><p>Pedro Pardal</p></a><p><a href=/legal/legal-notice/>Aviso legal</a> |
<a href=/legal/cookie-policy/>Política de cookies</a> |
<a href=/legal/privacy-policy/>Política de privacidad</a></p></div><div class="col-lg-6 social-media"><ul class="list-inline text-lg-right mt-3 mt-lg-0"><li class=list-inline-item><a target=_blank href=https://x.com/ppardalj><img src=/assets/img/social/twitter.svg></a></li><li class=list-inline-item><a target=_blank href=https://linkedin.com/in/ppardalj><img src=/assets/img/social/linkedin.svg></a></li><li class=list-inline-item><a target=_blank href=https://www.youtube.com/@ppardalj><img src=/assets/img/social/youtube.svg></a></li><li class=list-inline-item><a target=_blank href=https://github.com/ppardalj><img src=/assets/img/social/github.svg></a></li></ul></div></div></div></footer><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js integrity=sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js integrity=sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl crossorigin=anonymous></script><script src=/assets/js/scroll.js></script><script src=/assets/js/redirect.js></script><script>function loadScript(e){var n=document.getElementsByTagName("head")[0],t=document.createElement("script");t.type="text/javascript",t.src="https://tracker.metricool.com/resources/be.js",t.onreadystatechange=e,t.onload=e,n.appendChild(t)}loadScript(function(){beTracker.t({hash:"45d30dfb71957d625ad900e4772a2d6a"})})</script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5f2bf2edad69c454"></script></body></html>