<!doctype html><html lang=es><head><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-PJM6WP")</script><meta charset=utf-8><title>Por que los mocks hacen tus tests mas fragiles (y que usar en su lugar) | Pedro Pardal</title>
<meta name=description content="Hay una alternativa mas robusta y expresiva: los fakes."><meta name=author content="Pedro Pardal"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:url" content="https://www.ppardalj.com/newsletter/2025/06/por-que-los-mocks-hacen-tus-tests-mas-fragiles-y-que-usar-en-su-lugar/"><meta property="og:site_name" content="Pedro Pardal"><meta property="og:title" content="Por que los mocks hacen tus tests mas fragiles (y que usar en su lugar)"><meta property="og:description" content="Hay una alternativa mas robusta y expresiva: los fakes."><meta property="og:locale" content="es"><meta property="og:type" content="article"><meta property="article:section" content="newsletter"><meta property="article:published_time" content="2025-06-11T00:00:00+00:00"><meta property="article:modified_time" content="2025-06-11T00:00:00+00:00"><meta property="article:tag" content="Newsletter"><meta property="og:image" content="https://www.ppardalj.com/images/blog/posts/programador.jpg"><meta itemprop=name content="Por que los mocks hacen tus tests mas fragiles (y que usar en su lugar)"><meta itemprop=description content="Hay una alternativa mas robusta y expresiva: los fakes."><meta itemprop=datePublished content="2025-06-11T00:00:00+00:00"><meta itemprop=dateModified content="2025-06-11T00:00:00+00:00"><meta itemprop=wordCount content="2491"><meta itemprop=image content="https://www.ppardalj.com/images/blog/posts/programador.jpg"><meta itemprop=keywords content="Newsletter"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.ppardalj.com/images/blog/posts/programador.jpg"><meta name=twitter:title content="Por que los mocks hacen tus tests mas fragiles (y que usar en su lugar)"><meta name=twitter:description content="Hay una alternativa mas robusta y expresiva: los fakes."><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css integrity=sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm crossorigin=anonymous><link rel=stylesheet href=https://www.ppardalj.com/scss/main.css><link rel=stylesheet href=https://www.ppardalj.com/scss/hero.css><script type=text/javascript id=hs-script-loader async defer src=//js.hs-scripts.com/8231847.js></script><link rel=stylesheet type=text/css href=https://cdn.jsdelivr.net/npm/cookieconsent@3/build/cookieconsent.min.css><link rel=stylesheet href=https://www.ppardalj.com/scss/blog.css><link rel=stylesheet href=https://www.ppardalj.com/scss/hero.css></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PJM6WP" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><nav class="navbar navbar-dark dark navbar-expand-lg navbar-shrink"><div class=container><a href=/ class=navbar-brand><p>Pedro Pardal</p></a><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarTogglerDemo01 aria-controls=navbarTogglerDemo01 aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarTogglerDemo01><ul class="navbar-nav ml-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Servicios</a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/team-coaching/>Team Coaching</a>
<a class=dropdown-item href=https://www.exeal.com/>Cursos</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownResources role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Recursos</a><div class=dropdown-menu aria-labelledby=navbarDropdownResources><a class=dropdown-item href=/newsletter/>Newsletter</a>
<a class=dropdown-item href=/blog/>Blog</a></div></li><li class=nav-item><a class="nav-link nav-button" href=/contacto/>Contacto</a></li></ul></div></div></nav><header class="hero hero-bg-img" style=background-image:url(/images/blog/posts/programador.jpg)><div class="hero-bg-img-mask bg-mask"><div class="container h-100"><div class="row h-100 align-items-center"><div class="col-12 text-center"><h1><span class=underline>Por que los mocks hacen tus tests mas fragiles (y que usar en su lugar)</span></h1></div></div></div></div></header><section id=sect-body><div class=container><article><p>Has escrito tus tests. Todo verde. Refactorizas una clase‚Ä¶ y <em>boom</em>, 17 tests rotos.</p><p>Pero no porque el sistema haya dejado de funcionar. Sino porque el <strong>mock esperaba un orden de llamadas exacto</strong>, y ahora haces <code>Validate()</code> antes que <code>DoThing()</code>.</p><p>O porque cambiaste el nombre de un m√©todo privado. Que ni siquiera forma parte del contrato p√∫blico. Pero el test lo usaba como si fuera sagrado.</p><p>Lo arreglas. Vuelve el verde. Respiras.</p><p>Y entonces lo ves: <strong>el test no valida ning√∫n resultado real</strong>. Solo que se llamaron ciertas funciones con ciertos par√°metros.</p><p>En producci√≥n, el sistema se comporta distinto. Y no te enteras hasta que ya es tarde.</p><p>Porque ese mock ‚Äîque parec√≠a tan √∫til‚Äî <strong>nunca estuvo obligado a comportarse como el sistema real</strong>.</p><p>Y ese es el problema de fondo: <strong>est√°s probando contra algo que no tiene por qu√© cumplir el contrato</strong>.</p><p>Para entender por qu√© ocurre ‚Äîy c√≥mo dejar de pisarte la manguera‚Äî, hay que volver a un concepto b√°sico del testing: los <strong>dobles de test</strong>.</p><hr><h2 id=qu√©-son-los-dobles-de-test-y-por-qu√©-importan>Qu√© son los dobles de test (y por qu√© importan)</h2><p>Cuando escribes un test y no quieres que participe una clase real (una base de datos, una API externa, un gateway de pagos‚Ä¶), usas un <em>doble de test</em>.</p><p>Un doble de test es, simplemente, <strong>una pieza que sustituye a otra en un test</strong>.</p><p>Dentro de esa categor√≠a hay varios tipos (stubs, spies, dummies‚Ä¶). Esta clasificaci√≥n viene del trabajo de Martin Fowler en su art√≠culo <a href=https://martinfowler.com/articles/mocksArentStubs.html><em>Mocks Aren‚Äôt Stubs</em></a>, donde explica las diferencias entre dobles basados en comportamiento (mocks) y los que simplemente simulan datos (fakes, stubs, etc.).</p><p>Sin embargo, para lo que nos interesa aqu√≠, podemos simplificar el mapa en dos grandes grupos: <strong>mocks</strong> y <strong>fakes</strong>.</p><h3 id=un-caso-a-testear-registro-de-usuario>Un caso a testear: registro de usuario</h3><p>Sup√≥n que tienes una clase <code>UserRegistrationService</code> que registra un usuario si no existe ya en el sistema:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserRegistrationService</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IUserRepository _repository;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> UserRegistrationService(IUserRepository repository)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _repository = repository;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> Register(<span style=color:#66d9ef>string</span> email)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> existing = _repository.FindByEmail(email);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (existing != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        _repository.Save(<span style=color:#66d9ef>new</span> User(email));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>La interfaz <code>IUserRepository</code> es simple:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IUserRepository</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Save(User user);
</span></span><span style=display:flex><span>    User? FindByEmail(<span style=color:#66d9ef>string</span> email);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Vamos a ver c√≥mo se puede testear esto con mocks&mldr; y con fakes.</p><h3 id=los-mocks>Los mocks</h3><p>Un <em>mock</em> es un objeto que <strong>configuras desde el test</strong> para que devuelva ciertos valores y registre las llamadas que se le hacen.</p><p>Lo usas as√≠:</p><ul><li>Le dices qu√© debe devolver si se llama al m√©todo X con el par√°metro Y.</li><li>Luego, despu√©s de ejecutar el c√≥digo, verificas que ese m√©todo se haya llamado como t√∫ esperabas.</li></ul><p>Es como un actor que <strong>sigue el guion que t√∫ le marcas,</strong> y luego te pasa el informe de todo lo que ha hecho.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> repoMock = <span style=color:#66d9ef>new</span> Mock&lt;IUserRepository&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>repoMock.Setup(r =&gt; r.FindByEmail(<span style=color:#e6db74>&#34;pedro@exeal.com&#34;</span>)).Returns((User?)<span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> service = <span style=color:#66d9ef>new</span> UserRegistrationService(repoMock.Object);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> result = service.Register(<span style=color:#e6db74>&#34;pedro@exeal.com&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Assert.True(result);
</span></span><span style=display:flex><span>repoMock.Verify(r =&gt; r.Save(It.Is&lt;User&gt;(u =&gt; u.Email == <span style=color:#e6db74>&#34;pedro@exeal.com&#34;</span>)));
</span></span></code></pre></div><p>Este test no valida ning√∫n resultado observable. Solo que se llamaron ciertos m√©todos con ciertos par√°metros.</p><p>El mock es como un actor que improvisa (pero mal) con tu guion: puede decir cualquier cosa‚Ä¶ incluso si contradice la historia.</p><h3 id=los-fakes>Los fakes</h3><p>Un <em>fake</em>, en cambio, es <strong>una implementaci√≥n funcional del contrato</strong>, que se comporta de forma coherente, aunque simplificada.</p><p>Por ejemplo: un <code>FakeUserRepository</code> que guarda usuarios en una lista en memoria. No hay <code>.Setup()</code>, no hay <code>.Verify()</code>. Solo comportamiento.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FakeUserRepository</span> : IUserRepository
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> List&lt;User&gt; _users = <span style=color:#66d9ef>new</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Save(User user) =&gt; _users.Add(user);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> User? FindByEmail(<span style=color:#66d9ef>string</span> email) =&gt;
</span></span><span style=display:flex><span>        _users.FirstOrDefault(u =&gt; u.Email == email);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> repo = <span style=color:#66d9ef>new</span> FakeUserRepository();
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> service = <span style=color:#66d9ef>new</span> UserRegistrationService(repo);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> result = service.Register(<span style=color:#e6db74>&#34;pedro@exeal.com&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Assert.True(result);
</span></span><span style=display:flex><span>Assert.NotNull(repo.FindByEmail(<span style=color:#e6db74>&#34;pedro@exeal.com&#34;</span>));
</span></span></code></pre></div><p>Aqu√≠ el test valida un efecto real: que el usuario se ha guardado correctamente.</p><p>No le importa c√≥mo se logr√≥ internamente. Le importa lo que el sistema hizo.</p><p>Entender esta diferencia lo cambia todo. Porque, aunque los dos sirven para sustituir dependencias en los tests, <strong>solo uno de ellos se comporta como un sistema real</strong>. Y no es el mock.</p><hr><h2 id=por-qu√©-los-mocks-generan-dolor><strong>Por qu√© los mocks generan dolor</strong></h2><p>A primera vista, usar mocks parece c√≥modo: sustituyen dependencias externas, te permiten configurar comportamientos‚Ä¶ y puedes verificar que se llama a lo que toca.</p><p>Pero esa comodidad tiene trampa.</p><p>En cuanto haces un refactor m√≠nimamente serio, los tests empiezan a romperse. No porque el sistema falle, sino porque <strong>el test estaba acoplado a la implementaci√≥n interna</strong>.</p><h3 id=1-fragilidad-ante-refactors>1. Fragilidad ante refactors</h3><p>¬øExtraes un m√©todo privado? ¬øCambias el orden de ejecuci√≥n? ¬øRenombras un par√°metro?</p><p>Aunque el comportamiento externo no cambie, los tests con mocks pueden fallar.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>repoMock.Verify(r =&gt; r.Save(...));
</span></span></code></pre></div><p>Este tipo de verificaci√≥n exige que el sistema funcione de una forma exacta. Si el <em>c√≥mo</em> cambia, el test falla‚Ä¶ aunque el <em>qu√©</em> siga estando bien.</p><h3 id=2-testean-configuraciones-no-comportamientos>2. Testean configuraciones, no comportamientos</h3><p>Un mock es tan listo como t√∫ lo hagas. T√∫ decides qu√© devuelve. Pero lo haces de forma aislada, sin que dependa del flujo de ejecuci√≥n.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>repoMock.Setup(r =&gt; r.FindByEmail(<span style=color:#e6db74>&#34;pedro@exeal.com&#34;</span>)).Returns((User?)<span style=color:#66d9ef>null</span>);
</span></span></code></pre></div><p>Aqu√≠ el test declara que el usuario no existe, pero sin ninguna causa previa. <strong>No est√°s describiendo el estado real del sistema, sino inyectando una simulaci√≥n arbitraria.</strong></p><p>Eso crea una falsa sensaci√≥n de seguridad. El test pasa, pero no valida el comportamiento del sistema real.</p><p>Has sido ‚Äúmockeado‚Äù :P</p><h3 id=3-ruido-y-verbosidad>3. Ruido y verbosidad</h3><p>Mocks requieren configurar <code>.Setup()</code>, <code>.Returns()</code>, <code>.Verify()</code>&mldr;</p><p>Y si hay varios en un mismo test, el c√≥digo se llena de detalles irrelevantes.</p><p>Cuesta leer qu√© se est√° probando. Cuesta ver la intenci√≥n. El test ya no cuenta una historia: es una receta mec√°nica de configuraciones.</p><h3 id=4-alta-duplicaci√≥n-y-mantenimiento-costoso>4. Alta duplicaci√≥n y mantenimiento costoso</h3><p>Cada test repite las mismas configuraciones. Cambias una firma o una l√≥gica interna‚Ä¶ y tienes que tocar decenas de l√≠neas en decenas de tests.</p><p>Ese esfuerzo se multiplica con el tiempo y acaba erosionando la confianza en el valor de los tests.</p><h3 id=5-rompen-el-contrato-sem√°ntico-de-las-dependencias>5. Rompen el contrato sem√°ntico de las dependencias</h3><p>El mayor riesgo: puedes configurar un mock para devolver respuestas que <strong>no tienen sentido en ning√∫n flujo real</strong>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>repoMock.Setup(r =&gt; r.FindByEmail(<span style=color:#e6db74>&#34;pedro@exeal.com&#34;</span>))
</span></span><span style=display:flex><span>        .Returns(<span style=color:#66d9ef>new</span> User(<span style=color:#e6db74>&#34;pedro@exeal.com&#34;</span>));
</span></span></code></pre></div><p>Aqu√≠ el test simula que el usuario existe‚Ä¶ sin que nunca se haya guardado.</p><p>Ese desacoplamiento entre <em>lo que el sistema har√≠a</em> y <em>lo que el mock devuelve</em> <strong>rompe el contrato impl√≠cito entre las partes</strong>.</p><p>Ya no est√°s probando el sistema. Est√°s probando una historia inventada.</p><p>Gerard Meszaros lo resume bien en <a href=https://www.amazon.es/xUnit-Test-Patterns-Refactoring-Signature/dp/0131495054><em>xUnit Test Patterns</em></a>: cuando un doble no se comporta como su colaborador real, el test pierde valor como verificaci√≥n del sistema. Especialmente si la verificaci√≥n se basa en interacciones, no en resultados.</p><p>Hasta aqu√≠, hemos visto c√≥mo los mocks pueden darte una falsa sensaci√≥n de seguridad.</p><p>Pero‚Ä¶ ¬øcu√°l es la alternativa?</p><p>Visto lo que no funciona, vamos a ver qu√© s√≠ lo hace.</p><h2 id=qu√©-ventajas-tienen-los-fakes><strong>Qu√© ventajas tienen los fakes</strong></h2><p>Frente a los problemas de los mocks, los fakes ofrecen una alternativa m√°s robusta y sostenible. Son simples de escribir, f√°ciles de entender y se comportan como versiones m√≠nimas del sistema real.</p><p>Vamos con las ventajas concretas:</p><h3 id=1-se-escriben-una-vez-y-se-reutilizan>1. Se escriben una vez y se reutilizan</h3><p>Un fake es c√≥digo real. Lo implementas una vez ‚Äînormalmente en memoria‚Äî y puedes usarlo en todos los tests que lo necesiten.</p><p>Mientras que con mocks est√°s escribiendo <code>.Setup</code> y <code>.Returns</code> en cada test, con fakes lo √∫nico que cambias es el escenario.</p><h3 id=2-modelan-el-comportamiento-real-del-sistema>2. Modelan el comportamiento real del sistema</h3><p>El <code>FakeUserRepository</code> que vimos antes guarda usuarios en una lista y permite buscarlos.</p><p>No hay nada que configurar. Solo haces <code>Save()</code> y luego <code>FindByEmail()</code>.</p><p>Eso ya es suficiente para detectar errores de l√≥gica, flujos incoherentes o datos mal gestionados. Porque el fake <strong>tiene reglas internas reales</strong>, no una simulaci√≥n arbitraria.</p><h3 id=3-permiten-tests-orientados-a-resultados-no-a-llamadas>3. Permiten tests orientados a resultados, no a llamadas</h3><p>Con mocks, los tests suelen verificar <em>si se llam√≥ a algo</em>.</p><p>Con fakes, verificas <em>qu√© pas√≥ realmente</em>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// Con fake</span>
</span></span><span style=display:flex><span>service.Register(<span style=color:#e6db74>&#34;pedro@exeal.com&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> user = repo.FindByEmail(<span style=color:#e6db74>&#34;pedro@exeal.com&#34;</span>);
</span></span><span style=display:flex><span>Assert.NotNull(user);
</span></span></code></pre></div><p>Este test no necesita saber c√≥mo se implementa <code>Register()</code>. Solo le importa el resultado observable.</p><h3 id=4-pueden-actuar-como-contratos-ejecutables>4. Pueden actuar como contratos ejecutables</h3><p>Si test√©as bien tus fakes (con casos l√≠mite, reglas del dominio, validaciones&mldr;), acaban convirti√©ndose en <strong>especificaciones vivas</strong> del comportamiento esperado de la dependencia.</p><p>Son una forma de protegerte contra cambios arbitrarios, igual que lo har√≠as con tests de producci√≥n.</p><h3 id=5-no-necesitas-librer√≠as-externas>5. No necesitas librer√≠as externas</h3><p>Nada de frameworks. Nada de DSLs raros. Solo c√≥digo.</p><p>Y eso hace que tus tests sean m√°s portables, m√°s claros y menos fr√°giles.</p><hr><h2 id=cu√°ndo-tiene-sentido-usar-fakes-y-cu√°ndo-no><strong>Cu√°ndo tiene sentido usar fakes (y cu√°ndo no)</strong></h2><p>No todo se puede ‚Äîni se debe‚Äî fakear. Hay casos donde un mock es la opci√≥n m√°s razonable, <strong>no porque sea ideal, sino porque es suficiente</strong>.</p><h3 id=casos-ideales-para-usar-fakes>Casos ideales para usar fakes</h3><ul><li><strong>Repositorios</strong>: tienen comportamiento, almacenan estado y devuelven datos. Perfectos para fakear.</li><li><strong>Adaptadores a servicios externos</strong> (APIs de terceros, gateways de pagos, etc.): puedes simular su l√≥gica en memoria sin depender del mundo real.</li><li><strong>Colaboradores con reglas de negocio</strong>: si tiene condiciones, invariantes o efectos visibles, un fake bien dise√±ado ayuda a testear mejor.</li></ul><h3 id=casos-l√≠mite-donde-un-mock-es-suficiente-y-sensato>Casos l√≠mite donde un mock es suficiente (y sensato)</h3><ul><li><strong>Loggers, m√©tricas, sistemas de auditor√≠a</strong>: no devuelven nada, solo notifican. Mockearlos para verificar que se llam√≥ a <code>LogError()</code> puede ser suficiente.</li><li><strong>Notificaciones, emails, webhooks</strong>: si lo √∫nico que necesitas es comprobar que se dispar√≥ una acci√≥n, no tiene sentido montar un fake complejo.</li><li><strong>Sistemas tan simples que fakearlos ser√≠a m√°s trabajo que valor</strong>: si la colaboraci√≥n no aporta l√≥gica, construir un fake es sobreingenier√≠a.</li></ul><h3 id=regla-de-oro>Regla de oro:</h3><blockquote><p><em>Mocks para interacciones sin efecto.</em></p><p><em><strong>Fakes para colaboraciones con comportamiento.</strong></em></p></blockquote><p>Dicho de otro modo: si solo necesitas saber <em>si se llam√≥ a algo</em>, el mock vale.</p><p>Pero si quieres saber <em>qu√© hace ese algo</em>, entonces el fake es tu aliado.</p><h2 id=buenas-pr√°cticas-si-decides-usar-fakes><strong>Buenas pr√°cticas si decides usar fakes</strong></h2><p>Pasarte a los fakes no es solo cambiar c√≥mo sustituyes una dependencia.</p><p>Es adoptar un enfoque de testing m√°s realista, m√°s expresivo y m√°s conectado con el dominio.</p><p>Pero para que eso funcione, hay que hacerlos bien. Aqu√≠ van algunas pautas clave:</p><h3 id=1-test√©alos-como-si-fueran-c√≥digo-de-producci√≥n>1. Test√©alos como si fueran c√≥digo de producci√≥n</h3><p>Un fake no es un segundo plato. Si encapsula reglas del dominio, <strong>debe estar bien cubierto por tests</strong>.</p><ul><li>¬øQu√© pasa si llamas a <code>FindByEmail()</code> sin haber guardado nada?</li><li>¬øPermite duplicados? ¬øLanza excepci√≥n? ¬øDevuelve siempre el √∫ltimo?</li></ul><p>Aseg√∫rate de capturar casos l√≠mite, validar invariantes y cumplir pre/postcondiciones.</p><p>Cuanto m√°s robusto es el fake, m√°s confianza te da toda la suite.</p><h3 id=2-usa-la-gesti√≥n-de-errores-funcional-para-capturar-mejor-el-comportamiento>2. Usa la gesti√≥n de errores funcional para capturar mejor el comportamiento</h3><p>Una de las ventajas de usar fakes es que <strong>te obliga a pensar en serio c√≥mo deber√≠a comportarse una colaboraci√≥n</strong>.</p><p>Y eso incluye c√≥mo representar errores o condiciones excepcionales.</p><p>Por ejemplo:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>User? FindByEmail(<span style=color:#66d9ef>string</span> email);
</span></span></code></pre></div><p>Esta firma parece suficiente‚Ä¶ hasta que tienes que implementar el fake.</p><p>¬øDevuelves <code>null</code> si no lo encuentra? ¬øY si el email est√° mal formado? ¬øY si el sistema no est√° disponible?</p><p>Ah√≠ es donde te das cuenta de que la firma <strong>no te obliga a modelar expl√≠citamente los posibles resultados</strong>.</p><p>Y eso puede llevar a ambig√ºedades, bugs y tests fr√°giles.</p><p>Si usas un tipo como <code>Result&lt;User, NotFound></code> o <code>Either&lt;Error, User></code>, esa ambig√ºedad desaparece:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Result&lt;User, NotFound&gt; FindByEmail(<span style=color:#66d9ef>string</span> email);
</span></span></code></pre></div><p>Ahora el contrato es claro: o devuelves un usuario, o un error bien tipado.</p><p>Y tanto el fake como el c√≥digo de producci√≥n se benefician de esa precisi√≥n.</p><p>¬øPodr√≠as hacer esto con mocks? Claro.</p><p>Pero los mocks no te obligan a enfrentarte al dise√±o.</p><p>Los fakes, s√≠. Y eso es parte de su valor.</p><h3 id=3-mantenlos-cerca-del-dominio>3. Mantenlos cerca del dominio</h3><p>Un buen fake <strong>cuenta una historia coherente</strong>.</p><p>Si est√°s modelando un <code>FakePaymentGateway</code>, ¬øqu√© ocurre si el usuario no tiene saldo?</p><p>¬øPermite repetir pagos con el mismo ID? ¬øPuedes consultar el estado de un cobro?</p><p>Cuanto m√°s alineado est√© con las reglas reales, m√°s √∫til ser√° para detectar errores <em>antes</em> de llegar a producci√≥n.</p><h3 id=en-resumen>En resumen:</h3><blockquote><p><em>Si tratas a tus fakes como c√≥digo de juguete, obtendr√°s tests de juguete.
Si los tratas como parte del sistema, se convierten en contratos ejecutables.</em></p></blockquote><hr><h3 id=c√≥mo-migrar-de-mocks-a-fakes-paso-a-paso><strong>C√≥mo migrar de mocks a fakes (paso a paso)</strong></h3><p>No hace falta reescribir toda tu suite de tests de golpe.</p><p>Puedes empezar poco a poco, y <strong>cada paso mejora tu dise√±o y tus tests</strong>.</p><p>Aqu√≠ va una gu√≠a para migrar de mocks a fakes de forma progresiva y sostenible:</p><h3 id=paso-1-identifica-los-colaboradores-que-m√°s-mockeas>Paso 1. Identifica los colaboradores que m√°s mockeas</h3><p>Abre tus tests y mira qu√© dependencias est√°s simulando constantemente.</p><p>Suelen ser cosas como:</p><ul><li>Repositorios</li><li>Gateways a servicios externos</li><li>Adaptadores de infraestructura</li></ul><p><strong>Si ves <code>.Setup(...)</code> y <code>.Returns(...)</code> repetido en todos lados, tienes un candidato.</strong></p><h3 id=paso-2-escribe-un-primer-fakex-sencillo>Paso 2. Escribe un primer <code>FakeX</code> sencillo</h3><p>Crea una implementaci√≥n in-memory que haga lo m√≠nimo para comportarse como la clase real.</p><p>Por ejemplo, si tienes un <code>IUserRepository</code>, escribe un <code>FakeUserRepository</code> que guarde usuarios en una lista y te deje buscarlos.</p><p>No hace falta cubrir todos los casos al principio. <strong>Empieza por los tests m√°s simples.</strong></p><h3 id=paso-3-testea-ese-fake-como-si-fuera-c√≥digo-de-producci√≥n>Paso 3. Testea ese fake como si fuera c√≥digo de producci√≥n</h3><p>El fake <strong>no es c√≥digo de test</strong>, es <strong>infraestructura de confianza</strong>.</p><p>Escribe tests para validar:</p><ul><li>Qu√© pasa si buscas un usuario que no existe</li><li>Qu√© ocurre si guardas dos con el mismo email</li><li>Qu√© invariantes debe cumplir ese colaborador</li></ul><p><strong>Cuanto m√°s lo testees, m√°s robusta ser√° tu suite.</strong></p><h3 id=paso-4-sustituye-mocks-por-el-fake>Paso 4. Sustituye mocks por el fake</h3><p>Ve test a test. Sustituye el mock por tu fake, elimina <code>.Setup()</code> y <code>.Verify()</code>, y valida el resultado del sistema directamente.</p><p>Lo m√°s probable es que los tests sean m√°s cortos, m√°s claros y m√°s expresivos.</p><h3 id=paso-5-usa-los-fallos-como-oportunidad>Paso 5. Usa los fallos como oportunidad</h3><p>Puede que alg√∫n test empiece a fallar.</p><p>Bien.</p><p>Eso te est√° diciendo que hab√≠a una <strong>asimetr√≠a entre lo que el mock promet√≠a y lo que el sistema real hace</strong>.</p><p>Aprovecha para replantear:</p><ul><li>¬øEst√° bien dise√±ada esta interfaz?</li><li>¬øEl sistema se comporta como esperas?</li><li>¬øD√≥nde deber√≠a estar esta l√≥gica?</li></ul><p>Migrar a fakes es tambi√©n una forma de <strong>refinar tus colaboraciones y tus contratos</strong>.</p><hr><h2 id=conclusi√≥n-menos-mocks-mejores-tests>Conclusi√≥n: menos mocks, mejores tests</h2><p>Muchos tests pasan.</p><p>Pocos tests protegen de verdad.</p><p>Cuando abusamos de los mocks, no estamos validando comportamiento real. Solo estamos comprobando que el sistema hace las llamadas que esper√°bamos‚Ä¶ aunque el resultado final sea incorrecto.</p><p>Los fakes, bien usados, nos devuelven a lo importante: el comportamiento observable, el dise√±o orientado a prop√≥sito, la confianza real en que nuestro sistema hace lo que dice hacer.</p><p>Pero eso es solo una pieza del puzzle.</p><h3 id=y-si-el-problema-no-fuera-solo-el-tipo-de-doble-que-usas>¬øY si el problema no fuera solo el tipo de doble que usas?</h3><ul><li>¬øC√≥mo sabes que tus tests cubren lo que importa?</li><li>¬øQu√© tipo de test es el adecuado en cada capa?</li><li>¬øC√≥mo construir una red de tests que aguante el paso del tiempo?</li></ul><p>Aqu√≠ hemos hablado de mocks y fakes.</p><p>En la formaci√≥n <strong>‚ÄúA prueba de fallos‚Äù</strong>, vamos un paso m√°s all√°: te ense√±o a dise√±ar toda tu estrategia de testing para que sea una red de seguridad real ‚Äî sin agujeros, sin ruido y sin sobrecoste.</p><p>üëâ <a href=http://www.exeal.com/cursos/a-prueba-de-fallos><strong>Descubre c√≥mo blindar tu sistema con una estrategia de tests que aguanta lo que le eches.</strong></a></p><p>Si alguna vez has tenido bugs en producci√≥n con todos los tests en verde, esta formaci√≥n te ayudar√° a que no vuelva a pasar.</p><p>Un abrazo,</p><p>Pedro</p></article></div><div class=container><div class="row h-100 align-items-center"><div class="col-12 text-center"><ul class="tags tags-dark"><li><a href=https://www.ppardalj.com/tags/newsletter/>#newsletter</a></li></ul><div class=addthis_inline_share_toolbox></div></div></div></div></section><footer class=black><div class=container><div class="row align-items-center"><div class="col-lg-6 text-lg-left"><a href=/><p>Pedro Pardal</p></a><p><a href=/legal/legal-notice/>Aviso legal</a> |
<a href=/legal/cookie-policy/>Pol√≠tica de cookies</a> |
<a href=/legal/privacy-policy/>Pol√≠tica de privacidad</a></p></div><div class="col-lg-6 social-media"><ul class="list-inline text-lg-right mt-3 mt-lg-0"><li class=list-inline-item><a target=_blank href=https://x.com/ppardalj><img src=/assets/img/social/twitter.svg></a></li><li class=list-inline-item><a target=_blank href=https://linkedin.com/in/ppardalj><img src=/assets/img/social/linkedin.svg></a></li><li class=list-inline-item><a target=_blank href=https://www.youtube.com/@ppardalj><img src=/assets/img/social/youtube.svg></a></li><li class=list-inline-item><a target=_blank href=https://github.com/ppardalj><img src=/assets/img/social/github.svg></a></li></ul></div></div></div></footer><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js integrity=sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js integrity=sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl crossorigin=anonymous></script><script src=/assets/js/scroll.js></script><script src=/assets/js/redirect.js></script><script>function loadScript(e){var n=document.getElementsByTagName("head")[0],t=document.createElement("script");t.type="text/javascript",t.src="https://tracker.metricool.com/resources/be.js",t.onreadystatechange=e,t.onload=e,n.appendChild(t)}loadScript(function(){beTracker.t({hash:"45d30dfb71957d625ad900e4772a2d6a"})})</script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5f2bf2edad69c454"></script></body></html>